<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJTin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-11T16:13:57.319Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJTin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A guide to this in JavaScript</title>
    <link href="http://yoursite.com/2019/02/01/A-guide-to-this-in-JavaScript/"/>
    <id>http://yoursite.com/2019/02/01/A-guide-to-this-in-JavaScript/</id>
    <published>2019-02-01T11:50:58.000Z</published>
    <updated>2019-02-11T16:13:57.319Z</updated>
    
    <content type="html"><![CDATA[<p>原文参考<a href="https://medium.freecodecamp.org/a-guide-to-this-in-javascript-e3b9daef4df1" target="_blank" rel="noopener">https://medium.freecodecamp.org/a-guide-to-this-in-javascript-e3b9daef4df1</a></p><p><br><br><img src="/2019/02/01/A-guide-to-this-in-JavaScript/you_got_this.jpeg" title="you got this"><br><br><br><code>this</code> 关键词是Javascript中最广为使用的并且令人误解的词。今天我将尝试改变它。</p><p>当学习代词时，让我们回到古老的学校时代。</p><blockquote><p>菲尔普斯游得很快，因为他想赢得比赛。</p></blockquote><p>注意代词<code>he</code>的使用。我们在这不直接称呼菲尔普斯但是用代词<code>he</code>指代菲尔普斯。类似地，JavaScript使用<code>this</code>关键字作为指示对象来引用上下文中的对象，即主题。</p><p>例如：<br><br><br><img src="/2019/02/01/A-guide-to-this-in-JavaScript/ex1.png" title="example"><br><br></p><p>在上面的代码中，我们有一个对象<code>car</code>，它有<code>make</code>,<code>model</code>和<code>fullName</code>属性。<br><code>fullName</code>的值是一个<code>function</code>，它可以用两种不同的语法打印<code>car</code>的全称</p><ul><li><p>使用<code>this =&gt; this.make+” “ +this.model</code>，这个<code>this</code>指向上下文中的对象，所以<code>this.make</code>实际上是<code>car.make</code>,并且<code>this.model</code>也是如此</p></li><li><p>使用点表示法，我们可以访问对象的属性<code>car.make</code>和<code>car.model</code>。<br><br></p></li></ul><h1 id="这就是this"><a href="#这就是this" class="headerlink" title="这就是this!"></a>这就是<code>this</code>!</h1><p>现在我们已经理解了<code>this</code>是什么，这只是最基础的用法，让我们来做一些规则以致于我们可以记住。</p><p>JS中的<code>this</code>关键词指向它所属的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var car=&#123;</span><br><span class="line">  make:&apos;....&apos;</span><br><span class="line">  func:()=&gt;&#123;</span><br><span class="line">    console.log(this.make)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码片段中的<code>this</code>属于对象<code>car</code></p><p>依赖于用法，它有不同的值</p><ol><li>在一个方法里</li><li>在一个函数里</li><li>单独</li><li>在一个事件中</li><li><code>call()</code>和<code>apply()</code></li></ol><p><br><br><strong>在一个方法里</strong></p><p>当<code>this</code>在一个方法里使用，它指向方法所有者对象。</p><p>在一个对象中的定义的函数被叫做方法。让我们再举一次<code>car</code>的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var car= &#123;</span><br><span class="line">  make: &quot;Lamborghini&quot;,</span><br><span class="line">  model: &quot;Huracán&quot;,</span><br><span class="line">  fullName: function () &#123;</span><br><span class="line">    console.log(this.make+&quot; &quot; +this.model);</span><br><span class="line">    console.log(car.make+ &quot; &quot; +car.model);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">car.fullName();</span><br></pre></td></tr></table></figure><p><code>fullName()</code>在这里是一个方法。在这个方法里的<code>this</code>属于<code>car</code><br><br><br><strong>在一个函数里</strong></p><p>在一个函数里，<code>this</code>有一点复杂。首先要理解的是，与所有对象都具有属性一样，函数也具有属性。无论函数何时执行，它都能获取<code>this</code>属性，该属性是一个变量，其中包含调用它的对象的值。</p><p>如果函数没有被对象调用，那么函数内部的<code>this</code>属于全局对象，称之为窗口。在这个案例里，<code>this</code>将引用全局作用域中定义的值。让我们看一个更好理解的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var make= &quot;Mclaren&quot;;</span><br><span class="line">var model= &quot;720s&quot;</span><br><span class="line">function fullName()&#123; </span><br><span class="line">  console.log(this.make+ &quot; &quot; + this.model);</span><br><span class="line">&#125;</span><br><span class="line">var car = &#123;</span><br><span class="line">    make:&quot;Lamborghini&quot;,</span><br><span class="line">    model:&quot;Huracán&quot;,</span><br><span class="line">    fullName:function () &#123;</span><br><span class="line">      console.log (this.make + &quot; &quot; + this.model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">car.fullName(); // Lmborghini Huracán</span><br><span class="line">window.fullName(); // Mclaren 720S</span><br><span class="line">fullName(); // Mclaren 720S</span><br></pre></td></tr></table></figure><p>这里<code>make</code>，<code>model</code>和<code>fullName</code>是全局定义的，而<code>car</code>对象也有<code>fullName</code>的实现。当<code>car</code>对象被调用时，这指的是在对象内定义的属性。另一方面，其他两个函数调用是相同的并返回全局定义的属性。<br><br><br><strong>单独</strong></p><p>当单独使用而不是在任何函数或对象内部时，<code>this</code>指的是全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var make = &apos;Mclaren&apos;;</span><br><span class="line">var model = &apos;720s&apos;</span><br><span class="line">var name = &apos;Ferrari&apos;;</span><br><span class="line">console.log(this.name); //Ferrari</span><br></pre></td></tr></table></figure></p><p>这里的<code>this</code>指的是全局名称属性。</p><p><br><br><strong>在一个事件中</strong></p><p>事件可以是任何类型，但为了简单和清晰起见，让我们进行点击事件。<br><img src="/2019/02/01/A-guide-to-this-in-JavaScript/123.jpeg"></p><p>只要单击一个按钮并引发一个事件，它就可以调用另一个函数来根据点击执行某个任务。如果<code>this</code>在函数内部使用，它将引用引发事件的元素。在DOM中，所有元素都存储为对象。这就是为什么当引发一个事件时它会引用该元素，因为该<code>webpage</code>元素实际上是DOM中的一个对象。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;this.style.display=&apos;none&apos;&quot;&gt;</span><br><span class="line">  Remove Me!</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p><br><br><strong><code>call()</code>、<code>apply()</code>&amp; <code>bind()</code></strong></p><ul><li>bind：允许我们在方法上设置this的值。</li><li>call和apply：允许我们借用函数并在函数调用上设置<code>this</code>的值。<br><br></li></ul><h1 id="未完待续···"><a href="#未完待续···" class="headerlink" title="未完待续···"></a>未完待续···</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文参考&lt;a href=&quot;https://medium.freecodecamp.org/a-guide-to-this-in-javascript-e3b9daef4df1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.fr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【前端该懂的服务器知识】linux卸载nginx</title>
    <link href="http://yoursite.com/2019/01/27/%E3%80%90%E5%89%8D%E7%AB%AF%E8%AF%A5%E6%87%82%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9F%A5%E8%AF%86%E3%80%91linux%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDnginx/"/>
    <id>http://yoursite.com/2019/01/27/【前端该懂的服务器知识】linux彻底卸载nginx/</id>
    <published>2019-01-27T08:01:19.000Z</published>
    <updated>2019-01-30T07:21:57.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>  前段时间搞的AWS的服务器发现nginx的配置压根就没配对，所以趁着周末解决一下，然后网上找了一些资料，发现和自己原先弄的nginx路径差异很大，奈何我头铁，强撸一波（灰飞烟灭，唉～～～）</p><p>  最终结果：凉得很透！！！已经弄的回不了头了，只好全部打翻，重新来一次（毕竟还年轻嘛～～～～😆😆😆😆😆😆）</p><p>  既然出了问题，那就先从卸载删除开始吧，请各位看官往下看～～～👇👇👇<br><br></p><h1 id="1-删除nginx，包括配置文件"><a href="#1-删除nginx，包括配置文件" class="headerlink" title="1.删除nginx，包括配置文件"></a>1.删除nginx，包括配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove nginx</span><br></pre></td></tr></table></figure><h1 id="2-自动清除全部不使用的软件包"><a href="#2-自动清除全部不使用的软件包" class="headerlink" title="2.自动清除全部不使用的软件包"></a>2.自动清除全部不使用的软件包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure><h1 id="3-查找与nginx相关的软件"><a href="#3-查找与nginx相关的软件" class="headerlink" title="3.查找与nginx相关的软件"></a>3.查找与nginx相关的软件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --get-selections | grep nginx</span><br></pre></td></tr></table></figure><h1 id="4-删除第三步查询出来的结果"><a href="#4-删除第三步查询出来的结果" class="headerlink" title="4.删除第三步查询出来的结果"></a>4.删除第三步查询出来的结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove &lt;软件的名称&gt;</span><br></pre></td></tr></table></figure><h1 id="5-至此，关于nginx的文件及配置文件已经完全卸载了"><a href="#5-至此，关于nginx的文件及配置文件已经完全卸载了" class="headerlink" title="5.至此，关于nginx的文件及配置文件已经完全卸载了"></a>5.至此，关于nginx的文件及配置文件已经完全卸载了</h1><p>你以为这就结束了吗？<br><br></p><p></p><h1>too young ，too simple</h1><br><br><br>请继续往下看👇👇👇👇👇👇<p></p><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p><h1 id="6-查看nginx正在运行的进程"><a href="#6-查看nginx正在运行的进程" class="headerlink" title="6.查看nginx正在运行的进程"></a>6.查看nginx正在运行的进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>一般执行完此命令后，nginx还是启动着的,比如下面这样：</p><table><thead><tr><th style="text-align:center">xxx</th><th style="text-align:center">xxx</th><th style="text-align:center">xxx</th><th style="text-align:center">xxx</th></tr></thead><tbody><tr><td style="text-align:center">root</td><td style="text-align:center">7875</td><td style="text-align:center">2317</td><td style="text-align:center">nginx: master process /usr/sbin/nginx</td></tr><tr><td style="text-align:center">www-data</td><td style="text-align:center">7876</td><td style="text-align:center">7875</td><td style="text-align:center">nginx: worker process</td></tr><tr><td style="text-align:center">xxxxxxx</td><td style="text-align:center">8321</td><td style="text-align:center">3510</td><td style="text-align:center">grep –color=auto nginx</td></tr></tbody></table><h1 id="7-kill-nginx进程"><a href="#7-kill-nginx进程" class="headerlink" title="7.kill nginx进程"></a>7.kill nginx进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill  -9  7875 7876</span><br></pre></td></tr></table></figure><h1 id="8-全局查找与nginx相关的文件"><a href="#8-全局查找与nginx相关的文件" class="headerlink" title="8.全局查找与nginx相关的文件"></a>8.全局查找与nginx相关的文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  find  /  -name  nginx*</span><br></pre></td></tr></table></figure><h1 id="9-删除第8步列出的所有文件"><a href="#9-删除第8步列出的所有文件" class="headerlink" title="9.删除第8步列出的所有文件"></a>9.删除第8步列出的所有文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf file</span><br></pre></td></tr></table></figure><h1 id="10-恭喜你！！！"><a href="#10-恭喜你！！！" class="headerlink" title="10.恭喜你！！！"></a>10.恭喜你！！！</h1><p>这次nginx被你彻底删除了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;  前段时间搞的AWS的服务器发现nginx的配置压根就没配对，所以趁着周末解决一下，然后网上找了一些资料，发现和自己原先弄的ngi
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Interview-Questions</title>
    <link href="http://yoursite.com/2019/01/24/Interview-Questions/"/>
    <id>http://yoursite.com/2019/01/24/Interview-Questions/</id>
    <published>2019-01-24T10:44:08.000Z</published>
    <updated>2019-01-30T07:57:24.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文只记录面试过程中遇到的面试题(不定更)，答案请自行百度(自己动手、丰衣足食)</p></blockquote><h1 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h1><p>1.谈谈对ssr的了解</p><p>2.react和vue的区别</p><p>3.vue数据驱动的原理</p><p>4.v-if和v-show的区别</p><p>5.单页如何做优化</p><p>6.vuex的理解</p><p>7.vue的生命周期</p><h1 id="Git知识"><a href="#Git知识" class="headerlink" title="Git知识"></a>Git知识</h1><p>1.git创建远程分支的流程</p><p>2.git中rebase是做什么的，有何意义</p><h1 id="非框架知识"><a href="#非框架知识" class="headerlink" title="非框架知识"></a>非框架知识</h1><p>1.serviceworker</p><p>2.哪些方式导致内存泄漏</p><p>3.本地存储及区别</p><p>4.闭包、作用及处理，垃圾回收器</p><p>5.按需加载（webpack）</p><p>6.阻止冒泡</p><p>7.css动画和js动画的区别</p><p>8.cdn的原理，哪些东西可以使用cdn</p><p>9.深拷贝和浅拷贝的区别</p><p>10.模块化</p><p>11.有哪几种继承</p><p>12.跨越的处理方案</p><p>13.对web标准的理解及对w3c的认识</p><p>14.css3和h5的新特性新属性</p><p>15.性能优化</p><p>16.jsonp的原理以及为什么不是真正的ajax</p><p>17.lazyload的原理</p><p>18.prototype为obj添加一个属性和方法，并使用（代码实现）</p><p>19.sea和require的区别、优缺点</p><p>20.es6</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文只记录面试过程中遇到的面试题(不定更)，答案请自行百度(自己动手、丰衣足食)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;框架知识&quot;&gt;&lt;a href=&quot;#框架知识&quot; class=&quot;headerlink&quot; title=&quot;框架知识&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>When to use var vs let vs const in JavaScript</title>
    <link href="http://yoursite.com/2019/01/21/When%20to%20use%20var%20vs%20let%20vs%20const%20in%20JavaScript/"/>
    <id>http://yoursite.com/2019/01/21/When to use var vs let vs const in JavaScript/</id>
    <published>2019-01-21T14:45:06.000Z</published>
    <updated>2019-01-30T07:23:17.404Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考</p><p><a href="https://medium.freecodecamp.org/var-vs-let-vs-const-in-javascript-2954ae48c037" target="_blank" rel="noopener">https://medium.freecodecamp.org/var-vs-let-vs-const-in-javascript-2954ae48c037</a></p><p>在这篇文章中，你将会在javascript（ES6）中学习两种新的方式创建变量，let和const。在此过程中，我们将看到var，let和const的不同之处，以及包括诸如函数与块作用域、变量提升和不变性等主题</p><p>ES2015（或者ES6）介绍了两种新的方式创建变量，let和const。但是在我们真正区分var,let和const不同点之前，你应该先了解一些前提条件。它们是变量声明vs初始化，作用域（特别是函数作用域），和变量提升</p><h1 id="变量声明vs初始化"><a href="#变量声明vs初始化" class="headerlink" title="变量声明vs初始化"></a>变量声明vs初始化</h1><p>一个变量声明介绍了一个新的标识符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var declaration</span><br></pre></td></tr></table></figure><p>上面我们创建了一个新的标识符叫做声明。在javascript中，当变量被创建，它们以undefined的值被初始化。这意味着，如果我们尝试打印声明的变量，我们将得到undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var declaration</span><br><span class="line">console.log(declaration)</span><br></pre></td></tr></table></figure><p>所以如果我们打印声明的变量，我们得到undefined</p><p>与变量声明相反，变量初始化是指当你首次给一个变量赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var declaration</span><br><span class="line">console.log(declaration) // undefined</span><br><span class="line">declaration = &apos;This is an initialization&apos;</span><br></pre></td></tr></table></figure><p>所以在这里我们通过赋值给已经声明当变量一个字符串来初始化它。</p><p>这就引导我们第二个概念了，作用域</p><h1 id="Scope-作用域"><a href="#Scope-作用域" class="headerlink" title="Scope(作用域)"></a>Scope(作用域)</h1><p>作用域定义了在你的程序里，变量和函数在哪里可以获取到。在JavaScript中，有两种类型的作用域–全局作用域和函数作用域，根据官方的规范</p><p>如果变量语句发生在函数声明中，则变量在这个函数中通过函数局部作用域来定义</p><p>这就意味着如果你使用var来创建一个函数，那么这个变量被运用于它所创建的函数，并且只能在该函数内部或者任何嵌套函数内部被访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getDate () &#123;</span><br><span class="line">  var date = new Date()</span><br><span class="line">  return date</span><br><span class="line">&#125;</span><br><span class="line">getDate()</span><br><span class="line">console.log(date) // ❌ Reference Error</span><br></pre></td></tr></table></figure><p>上面我们尝试获取一个被声明的函数之外的变量。因为date是作用域于getDate的函数，它只能被getDate它本身或者getDate中的任何嵌套函数所获取（如下所示）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getDate()&#123;</span><br><span class="line">    var date = new Date()</span><br><span class="line">    function formatDate()&#123;</span><br><span class="line">        return date.toDateString().slice(4) //可获取</span><br><span class="line">    &#125;</span><br><span class="line">    return formatDate()</span><br><span class="line">&#125;</span><br><span class="line">getDate()</span><br><span class="line">console.log(date) // Reference Error 引用错误</span><br></pre></td></tr></table></figure></p><p>现在让我们来看一个更高级的例子。假设我们有一个prices的数组，并且我们需要一个函数，这个函数接收一个像折扣的数组，并且返回一个折扣后的新数组。最后的目标可能看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discountPrices([100, 200, 300], .5)</span><br></pre></td></tr></table></figure><p>并且实现可能看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  var discounted = []  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好像很简单，但是这与块作用域有什么关系？看一下这个for循环，它声明的变量是否可以在它外部被访问呢？事实证明，是可以的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  var discounted = []  </span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果JavaScript是你所了解的唯一一个编程语言，你可能不会想什么。然而，如果你从另一门编程语言（特别是这门语言是封闭的作用域）开始使用JavaScript，那么你很可能对这发生对事情感到有点担心。</p><p>它没有真正的破碎，他只是有点怪异。在for循环之外，这没有一个理由仍然能够访问到i，discountedPrice，和finalPrice。它不会对我们有任何的好处，并且甚至可能在一定程度上对我们造成伤害。然而，因为用var声明的变量是函数作用域的，所以你可以这样做。</p><p>现在我们已经可以讨论过变量声明，初始化，和作用域，那么在我们深入了解let和const之前我们需要清除的最后一件事就是提升。</p><h1 id="Hoisting（提升）"><a href="#Hoisting（提升）" class="headerlink" title="Hoisting（提升）"></a>Hoisting（提升）</h1><p>记得早的时候我们说过，‘在JavaScript中，变量被创建时可以用undefined值来初始化。事实证明，这就是“Hoisting”的全部。JavaScript解析器在被“创建”的阶段将分配一个默认的值undefined给变量的声明。</p><blockquote><p>For a much more in depth guide on the Creation Phase, Hoisting, and Scopes see “The Ultimate Guide to Hoisting, Scopes, and Closures in JavaScript”.</p></blockquote><p>寻找更多更深入关于创建阶段，提升和作用域的指南，可以参阅 The Ultimate Guide to Hoisting, Scopes, and Closures in JavaScript</p><p>让我们看一下之前的例子和提升是如何影响它的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  var discounted = undefined</span><br><span class="line">  var i = undefined</span><br><span class="line">  var discountedPrice = undefined</span><br><span class="line">  var finalPrice = undefined  </span><br><span class="line">      discounted = []</span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125; </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意所有声明的变量都被分配一个默认的值undefined。这就是为什么如果你在变量被真正声明之前访问其中一个变量，你仅仅得到undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  console.log(discounted) // undefined  </span><br><span class="line">  var discounted = []  </span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你已经知道了有关var的每一件事，让我们最后讨论你为什么在这的重点：var，let和const的区别在哪里？</p><h1 id="var-VS-let-VS-const"><a href="#var-VS-let-VS-const" class="headerlink" title="var VS let VS const"></a>var VS let VS const</h1><p>首先，让我们比较var和let。var和let主要的不同点不是函数作用域，let是块作用域。</p><p>这就意味着一个变量用let关键字创建可以被“块”内部以及任何嵌套的块中所访问。当我说“块”时，我是指像在一个for循环或者一个if语句中用一个大括号{}包围起来的任何东西</p><p>所以让我们最后一次回顾下我们的discountPrices函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  var discounted = []  </span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记住我们能够在for循环之外打印i，discountedPrice和finalPrice，因为它们被var声明，并且var是一个函数作用域，但是现在，如果我们改变这些var声明，使用let声明，并且尝试运行它，会发生什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  let discounted = []  </span><br><span class="line">  for (let i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    let discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    let finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br><span class="line">discountPrices([100, 200, 300], .5) // ❌ ReferenceError: i is not defined</span><br></pre></td></tr></table></figure></p><p>我们得到ReferenceError: i is not defined.这告诉我们的是，用let声明变量是块作用域而不是函数作用域。所以尝试在它们声明的“块”之外访问i（或者discountedPrice or finalPrice）将给我们一个引用错误，正如我们刚才所看到的。</p><h1 id="var-VS-let"><a href="#var-VS-let" class="headerlink" title="var VS let"></a>var VS let</h1><blockquote><p>var: function scopedlet: block scoped</p></blockquote><p>下一个区别与提升相关。之前我们说过，提升的定义是“JavaScript解析器将在“创建”阶段分配声明的变量一个默认值undefined”我们甚至在声明变量之前通过打印一个变量看到了这个行为（你得到了undefined）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  console.log(discounted) // undefined  </span><br><span class="line">  var discounted = []  </span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我想不到任何你想要在声明变量之前访问变量的案例。这看起来就像抛出一个引用错误也比返回undefined更好</p><p>事实上，这就是let做的事情。如果你尝试在声明之前访问一个用let声明过的变量，而不是得到undefined（就像用var声明那些变量），你将得到一个引用错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  console.log(discounted) // ❌ ReferenceError  </span><br><span class="line">  let discounted = []  </span><br><span class="line">  for (let i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    let discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    let finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="var-VS-let-1"><a href="#var-VS-let-1" class="headerlink" title="var VS let"></a>var VS let</h1><blockquote><p>var: function scoped<br>      undefined when accessing a variable before it’s declared</p></blockquote><blockquote><p>let: block scoped<br>    ReferenceError when accessing a variable before it’s declared</p></blockquote><h1 id="let-VS-const"><a href="#let-VS-const" class="headerlink" title="let VS const"></a>let VS const</h1><p>现在你理解了var和let的区别，那么const呢？事实上，const更像是let，然而，唯一的不同点就是你一旦用const分配了一个变量的值，你将不能重新分配一个新的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;Tyler&apos;</span><br><span class="line">const handle = &apos;tylermcginnis&apos;</span><br><span class="line">      name = &apos;Tyler McGinnis&apos; // ✅</span><br><span class="line">handle = &apos;@tylermcginnis&apos; // ❌ TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></p><p>上面的内容用let声明的变量可以重新赋值，但是用const声明的变量不能</p><p>非常酷，所以你只要想一个变量永远不变，你可以用const来声明。当然也不完全，仅仅因为用const声明一个变量并不意味着它是永远不变的，这完全意味着值不能被重新赋值。这就是一个很好的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Kim Kardashian&apos;</span><br><span class="line">&#125;</span><br><span class="line">person.name = &apos;Kim Kardashian West&apos; // ✅</span><br><span class="line">person = &#123;&#125; // ❌ Assignment to constant variable.</span><br></pre></td></tr></table></figure></p><p>注意，在一个对象上改变一个属性并不是重新赋值，所以即使一个对象用const声明，也不意味着你不能改变它的属性。这仅仅意味你不能重新分配一个新值</p><p>现在我们还没有回答最重要的问题是：你应该使用var，let或者const？最受欢迎的观点和我表述的观点是，你应该总是使用const，除非你知道变量将发生改变。这么做的原因是使用const，你向未来的自己以及必须阅读你代码的任何未来的开发者们发出信号，这个变量不应该改变。如果它将需要改变（像在for循环中），你应该使用let</p><p>所以，在可变的变量与不可改变的变量之间，就没有太多的东西剩下。这意味着你不应该再使用var</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>var是函数作用域，并且如果你尝试在实际声明之前使用一个var声明的变量，你将得到undefined。</p><p>const和let是块作用域，并且如果你尝试在实际声明之前使用let或const声明的变量，你将得到一个引用错误。</p><p>最后在let和const之间的区别是一旦你用const分配了一个值，你将不行重新赋值，但是用let可以</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.freecodecamp.org/var-vs-let-vs-const-in-javascript-2954ae48c037&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My Introduction</title>
    <link href="http://yoursite.com/2019/01/21/My-Introduction/"/>
    <id>http://yoursite.com/2019/01/21/My-Introduction/</id>
    <published>2019-01-21T14:04:39.000Z</published>
    <updated>2019-01-30T07:02:34.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>昨天，永远属于过去，昨天，如一颗陨落的流星划过天际，来不及招呼。</p><p>回望昨天，已是过去，过去早已不再清晰，变得模糊。</p><p>因此每一个昨天，都值得被记录下来。</p><p>从今天开始，记录也就开始了～～～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyIntroduction: &#123;</span><br><span class="line">  name: &quot;LJTin&quot;,</span><br><span class="line">  Job: &quot;Front End Engineer&quot;,</span><br><span class="line">  GraduationTime: 2016,</span><br><span class="line">  Hobbies: [&quot;交友&quot;, &quot;瞎折腾&quot;, &quot;学习&quot;],</span><br><span class="line">  MainTech: [&quot;Vue&quot;, &quot;React&quot;, &quot;Node&quot;, &quot;Koa&quot;, &quot;Express&quot;, &quot;mpvue&quot;, &quot;小程序&quot;],</span><br><span class="line">  SecondaryTech:[&quot;linux&quot;, &quot;python&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果各位大佬看到了这里，那么有猿千里来相会吧：</p><p>  email：<a href="mailto:jiantinglian619@gmail.com" target="_blank" rel="noopener">jiantinglian619@gmail.com</a><br>  wechat：ai562751028</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;昨天，永远属于过去，昨天，如一颗陨落的流星划过天际，来不及招呼。&lt;/p&gt;
&lt;p&gt;回望昨天，已是过去，过去早已不再清晰，变得模糊。&lt;/
      
    
    </summary>
    
    
  </entry>
  
</feed>
