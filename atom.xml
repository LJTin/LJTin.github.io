<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJTin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-13T15:42:10.079Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJTin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PM2</title>
    <link href="http://yoursite.com/2019/02/13/PM2/"/>
    <id>http://yoursite.com/2019/02/13/PM2/</id>
    <published>2019-02-13T15:00:38.000Z</published>
    <updated>2019-02-13T15:42:10.079Z</updated>
    
    <content type="html"><![CDATA[<p>本文只记录PM2的运行时，需要其他版本的可点击以下链接👇👇👇<br>参考官方文档：<a href="https://pm2.io/doc/" target="_blank" rel="noopener">https://pm2.io/doc/</a></p><h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><p>PM2 Runtime是具有内置Load Balancer的Node.js应用程序的生产过程管理器。它允许您永久保持应用程序的活动，无需停机即可重新加载它们，并促进常见的Devops任务。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>请自行学习，使用搜索引擎或点击链接👆👆👆</p><h1 id="命令行大聚集：-以下-js可省略"><a href="#命令行大聚集：-以下-js可省略" class="headerlink" title="命令行大聚集：(以下.js可省略)"></a>命令行大聚集：(以下.js可省略)</h1><h2 id="常用的命令行"><a href="#常用的命令行" class="headerlink" title="常用的命令行"></a>常用的命令行</h2><p>启动应用程序</p><blockquote><p><code>pm2 start app.js</code></p></blockquote><p>文件更改时启动并自动重新启动链接</p><blockquote><p><code>pm2 start app.js --watch [--ignore-watch /*/]</code></p></blockquote><p>停止应用程序</p><blockquote><p><code>pm2 stop app.js</code></p></blockquote><p>停止并启动程序 </p><blockquote><p><code>pm2 restart app.js</code> </p></blockquote><p>启动时启动PM2</p><blockquote><p><code>pm2 startup</code></p></blockquote><p>以集群模式启动，使用-i选项 </p><blockquote><p><code>pm2 start app.js -i 4</code> (4为集群数量)<br><code>pm2 start app.js -i max</code>（max可以自动检测可用的CPU数量）</p></blockquote><p>展示pm2的列表 </p><blockquote><p><code>pm2 ls</code></p></blockquote><p>展示日志</p><blockquote><p><code>pm2 logs</code></p></blockquote><p>监控</p><blockquote><p><code>pm2 monit</code></p></blockquote><p>从列表中停止并删除一个进程 </p><blockquote><p><code>pm2 detele app</code></p></blockquote><h2 id="不常用"><a href="#不常用" class="headerlink" title="不常用"></a>不常用</h2><p>使用重新加载而不是重新启动0秒停机时间重新加载</p><blockquote><p><code>pm2 reload app</code></p></blockquote><p>重置重启计数器</p><blockquote><p><code>pm2 reset all</code></p></blockquote><p>未完待续······</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文只记录PM2的运行时，需要其他版本的可点击以下链接👇👇👇&lt;br&gt;参考官方文档：&lt;a href=&quot;https://pm2.io/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pm2.io/doc/&lt;/a&gt;&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>A guide to this in JavaScript Part-1</title>
    <link href="http://yoursite.com/2019/02/01/A-guide-to-this-in-JavaScript-Part-1/"/>
    <id>http://yoursite.com/2019/02/01/A-guide-to-this-in-JavaScript-Part-1/</id>
    <published>2019-02-01T11:50:58.000Z</published>
    <updated>2019-02-11T16:18:07.845Z</updated>
    
    <content type="html"><![CDATA[<p>原文参考<a href="https://medium.freecodecamp.org/a-guide-to-this-in-javascript-e3b9daef4df1" target="_blank" rel="noopener">https://medium.freecodecamp.org/a-guide-to-this-in-javascript-e3b9daef4df1</a></p><p><br><br><br><br><br><code>this</code> 关键词是Javascript中最广为使用的并且令人误解的词。今天我将尝试改变它。</p><p>当学习代词时，让我们回到古老的学校时代。</p><blockquote><p>菲尔普斯游得很快，因为他想赢得比赛。</p></blockquote><p>注意代词<code>he</code>的使用。我们在这不直接称呼菲尔普斯但是用代词<code>he</code>指代菲尔普斯。类似地，JavaScript使用<code>this</code>关键字作为指示对象来引用上下文中的对象，即主题。</p><p>例如：<br><br><br><br><br></p><p>在上面的代码中，我们有一个对象<code>car</code>，它有<code>make</code>,<code>model</code>和<code>fullName</code>属性。<br><code>fullName</code>的值是一个<code>function</code>，它可以用两种不同的语法打印<code>car</code>的全称</p><ul><li><p>使用<code>this =&gt; this.make+” “ +this.model</code>，这个<code>this</code>指向上下文中的对象，所以<code>this.make</code>实际上是<code>car.make</code>,并且<code>this.model</code>也是如此</p></li><li><p>使用点表示法，我们可以访问对象的属性<code>car.make</code>和<code>car.model</code>。<br><br></p></li></ul><h1 id="这就是this"><a href="#这就是this" class="headerlink" title="这就是this!"></a>这就是<code>this</code>!</h1><p>现在我们已经理解了<code>this</code>是什么，这只是最基础的用法，让我们来做一些规则以致于我们可以记住。</p><p>JS中的<code>this</code>关键词指向它所属的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var car=&#123;</span><br><span class="line">  make:&apos;....&apos;</span><br><span class="line">  func:()=&gt;&#123;</span><br><span class="line">    console.log(this.make)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码片段中的<code>this</code>属于对象<code>car</code></p><p>依赖于用法，它有不同的值</p><ol><li>在一个方法里</li><li>在一个函数里</li><li>单独</li><li>在一个事件中</li><li><code>call()</code>和<code>apply()</code></li></ol><p><br><br><strong>在一个方法里</strong></p><p>当<code>this</code>在一个方法里使用，它指向方法所有者对象。</p><p>在一个对象中的定义的函数被叫做方法。让我们再举一次<code>car</code>的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var car= &#123;</span><br><span class="line">  make: &quot;Lamborghini&quot;,</span><br><span class="line">  model: &quot;Huracán&quot;,</span><br><span class="line">  fullName: function () &#123;</span><br><span class="line">    console.log(this.make+&quot; &quot; +this.model);</span><br><span class="line">    console.log(car.make+ &quot; &quot; +car.model);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">car.fullName();</span><br></pre></td></tr></table></figure><p><code>fullName()</code>在这里是一个方法。在这个方法里的<code>this</code>属于<code>car</code><br><br><br><strong>在一个函数里</strong></p><p>在一个函数里，<code>this</code>有一点复杂。首先要理解的是，与所有对象都具有属性一样，函数也具有属性。无论函数何时执行，它都能获取<code>this</code>属性，该属性是一个变量，其中包含调用它的对象的值。</p><p>如果函数没有被对象调用，那么函数内部的<code>this</code>属于全局对象，称之为窗口。在这个案例里，<code>this</code>将引用全局作用域中定义的值。让我们看一个更好理解的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var make= &quot;Mclaren&quot;;</span><br><span class="line">var model= &quot;720s&quot;</span><br><span class="line">function fullName()&#123; </span><br><span class="line">  console.log(this.make+ &quot; &quot; + this.model);</span><br><span class="line">&#125;</span><br><span class="line">var car = &#123;</span><br><span class="line">    make:&quot;Lamborghini&quot;,</span><br><span class="line">    model:&quot;Huracán&quot;,</span><br><span class="line">    fullName:function () &#123;</span><br><span class="line">      console.log (this.make + &quot; &quot; + this.model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">car.fullName(); // Lmborghini Huracán</span><br><span class="line">window.fullName(); // Mclaren 720S</span><br><span class="line">fullName(); // Mclaren 720S</span><br></pre></td></tr></table></figure><p>这里<code>make</code>，<code>model</code>和<code>fullName</code>是全局定义的，而<code>car</code>对象也有<code>fullName</code>的实现。当<code>car</code>对象被调用时，这指的是在对象内定义的属性。另一方面，其他两个函数调用是相同的并返回全局定义的属性。<br><br><br><strong>单独</strong></p><p>当单独使用而不是在任何函数或对象内部时，<code>this</code>指的是全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var make = &apos;Mclaren&apos;;</span><br><span class="line">var model = &apos;720s&apos;</span><br><span class="line">var name = &apos;Ferrari&apos;;</span><br><span class="line">console.log(this.name); //Ferrari</span><br></pre></td></tr></table></figure></p><p>这里的<code>this</code>指的是全局名称属性。</p><p><br><br><strong>在一个事件中</strong></p><p>事件可以是任何类型，但为了简单和清晰起见，让我们进行点击事件。<br></p><p>只要单击一个按钮并引发一个事件，它就可以调用另一个函数来根据点击执行某个任务。如果<code>this</code>在函数内部使用，它将引用引发事件的元素。在DOM中，所有元素都存储为对象。这就是为什么当引发一个事件时它会引用该元素，因为该<code>webpage</code>元素实际上是DOM中的一个对象。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;this.style.display=&apos;none&apos;&quot;&gt;</span><br><span class="line">  Remove Me!</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p><br><br><strong><code>call()</code>、<code>apply()</code>&amp; <code>bind()</code></strong></p><ul><li>bind：允许我们在方法上设置this的值。</li><li>call和apply：允许我们借用函数并在函数调用上设置<code>this</code>的值。<br><br></li></ul><h1 id="未完待续···"><a href="#未完待续···" class="headerlink" title="未完待续···"></a>未完待续···</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文参考&lt;a href=&quot;https://medium.freecodecamp.org/a-guide-to-this-in-javascript-e3b9daef4df1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.fr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【前端该懂的服务器知识】linux卸载nginx</title>
    <link href="http://yoursite.com/2019/01/27/%E3%80%90%E5%89%8D%E7%AB%AF%E8%AF%A5%E6%87%82%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9F%A5%E8%AF%86%E3%80%91linux%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDnginx/"/>
    <id>http://yoursite.com/2019/01/27/【前端该懂的服务器知识】linux彻底卸载nginx/</id>
    <published>2019-01-27T08:01:19.000Z</published>
    <updated>2019-01-30T07:21:57.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>  前段时间搞的AWS的服务器发现nginx的配置压根就没配对，所以趁着周末解决一下，然后网上找了一些资料，发现和自己原先弄的nginx路径差异很大，奈何我头铁，强撸一波（灰飞烟灭，唉～～～）</p><p>  最终结果：凉得很透！！！已经弄的回不了头了，只好全部打翻，重新来一次（毕竟还年轻嘛～～～～😆😆😆😆😆😆）</p><p>  既然出了问题，那就先从卸载删除开始吧，请各位看官往下看～～～👇👇👇<br><br></p><h1 id="1-删除nginx，包括配置文件"><a href="#1-删除nginx，包括配置文件" class="headerlink" title="1.删除nginx，包括配置文件"></a>1.删除nginx，包括配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove nginx</span><br></pre></td></tr></table></figure><h1 id="2-自动清除全部不使用的软件包"><a href="#2-自动清除全部不使用的软件包" class="headerlink" title="2.自动清除全部不使用的软件包"></a>2.自动清除全部不使用的软件包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure><h1 id="3-查找与nginx相关的软件"><a href="#3-查找与nginx相关的软件" class="headerlink" title="3.查找与nginx相关的软件"></a>3.查找与nginx相关的软件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --get-selections | grep nginx</span><br></pre></td></tr></table></figure><h1 id="4-删除第三步查询出来的结果"><a href="#4-删除第三步查询出来的结果" class="headerlink" title="4.删除第三步查询出来的结果"></a>4.删除第三步查询出来的结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove &lt;软件的名称&gt;</span><br></pre></td></tr></table></figure><h1 id="5-至此，关于nginx的文件及配置文件已经完全卸载了"><a href="#5-至此，关于nginx的文件及配置文件已经完全卸载了" class="headerlink" title="5.至此，关于nginx的文件及配置文件已经完全卸载了"></a>5.至此，关于nginx的文件及配置文件已经完全卸载了</h1><p>你以为这就结束了吗？<br><br></p><p></p><h1>too young ，too simple</h1><br><br><br>请继续往下看👇👇👇👇👇👇<p></p><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p><h1 id="6-查看nginx正在运行的进程"><a href="#6-查看nginx正在运行的进程" class="headerlink" title="6.查看nginx正在运行的进程"></a>6.查看nginx正在运行的进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>一般执行完此命令后，nginx还是启动着的,比如下面这样：</p><table><thead><tr><th style="text-align:center">xxx</th><th style="text-align:center">xxx</th><th style="text-align:center">xxx</th><th style="text-align:center">xxx</th></tr></thead><tbody><tr><td style="text-align:center">root</td><td style="text-align:center">7875</td><td style="text-align:center">2317</td><td style="text-align:center">nginx: master process /usr/sbin/nginx</td></tr><tr><td style="text-align:center">www-data</td><td style="text-align:center">7876</td><td style="text-align:center">7875</td><td style="text-align:center">nginx: worker process</td></tr><tr><td style="text-align:center">xxxxxxx</td><td style="text-align:center">8321</td><td style="text-align:center">3510</td><td style="text-align:center">grep –color=auto nginx</td></tr></tbody></table><h1 id="7-kill-nginx进程"><a href="#7-kill-nginx进程" class="headerlink" title="7.kill nginx进程"></a>7.kill nginx进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill  -9  7875 7876</span><br></pre></td></tr></table></figure><h1 id="8-全局查找与nginx相关的文件"><a href="#8-全局查找与nginx相关的文件" class="headerlink" title="8.全局查找与nginx相关的文件"></a>8.全局查找与nginx相关的文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  find  /  -name  nginx*</span><br></pre></td></tr></table></figure><h1 id="9-删除第8步列出的所有文件"><a href="#9-删除第8步列出的所有文件" class="headerlink" title="9.删除第8步列出的所有文件"></a>9.删除第8步列出的所有文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf file</span><br></pre></td></tr></table></figure><h1 id="10-恭喜你！！！"><a href="#10-恭喜你！！！" class="headerlink" title="10.恭喜你！！！"></a>10.恭喜你！！！</h1><p>这次nginx被你彻底删除了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;  前段时间搞的AWS的服务器发现nginx的配置压根就没配对，所以趁着周末解决一下，然后网上找了一些资料，发现和自己原先弄的ngi
      
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Interview-Questions</title>
    <link href="http://yoursite.com/2019/01/24/Interview-Questions/"/>
    <id>http://yoursite.com/2019/01/24/Interview-Questions/</id>
    <published>2019-01-24T10:44:08.000Z</published>
    <updated>2019-02-14T15:38:20.744Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文只记录面试过程中遇到的面试题(不定更)，答案请自行百度(自己动手、丰衣足食)</p></blockquote><h1 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h1><p>1.谈谈对ssr的了解</p><blockquote><p>seo与首屏渲染快<br>比较适合首屏使用ssr进行快速渲染，更利于seo</p></blockquote><p>2.react和vue的区别</p><blockquote><p><strong>react</strong>:<br>1.all in js<br>        2.函数式<br>        3.单向数据流</p></blockquote><blockquote><p><strong>vue</strong>:<br>1.html css js在一个文件下<br>     2.响应式<br>     3.双向绑定</p></blockquote><p>3.vue数据驱动的原理</p><blockquote><p>1.vue在实例化过程中，遍历data所有的属性并使用Object.defineProperty将属性全转化为getter/setter<br>2.每个实例对象都有一个watcher，在模板编译过程中使用getter访问data的属性，并且标记为依赖，建立视图与数据的联系<br>3.当依赖的数据发生了变化，就调用了setter方法，watcher会对比前后两个值的变化，决定是否通知视图重新渲染</p></blockquote><p>4.v-if和v-show的区别</p><blockquote><p>1.DOM差异，CSS差异</p></blockquote><p>5.Proxy 相比于 defineProperty 的优势</p><blockquote><ul><li>数组变化也能监听到<ul><li>不需要深度遍历监听</li></ul></li></ul></blockquote><p>6.nextTick()</p><blockquote><p>官方解释：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p></blockquote><blockquote><p>何时使用：(DOM发生变化的操作（不严谨！！！具体看下面两个例子👇👇👇）)</p><ul><li>1.在created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。<br><strong>原因</strong>：是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，所以一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。mounted该钩子函数执行时所有的DOM挂载和渲染都已完成，因此不需要使用nextTick()。</li></ul></blockquote><ul><li>2.在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放进Vue.nextTick()的回调函数中。</li></ul><p>7.vue的生命周期</p><blockquote><p>参考本文，个人感觉写的比较详细了 <a href="https://segmentfault.com/a/1190000011381906" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011381906</a><br>也可参考本文，讲的比较精干<a href="https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-60" target="_blank" rel="noopener">https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-60</a></p></blockquote><p>8.beforeCreate和Created的区别：</p><blockquote><p>beforeCreate 获取不到el和data<br>Created 获取的到data，但获取不到el（mounted中可获取）</p></blockquote><h1 id="Git知识"><a href="#Git知识" class="headerlink" title="Git知识"></a>Git知识</h1><p>1.git中rebase是做什么的，有何意义</p><blockquote><p>把提交的记录变得流畅</p></blockquote><h1 id="非框架知识"><a href="#非框架知识" class="headerlink" title="非框架知识"></a>非框架知识</h1><p>1.serviceworker</p><blockquote><p>参考本文<a href="https://www.cnblogs.com/dojo-lzz/p/8047336.html" target="_blank" rel="noopener">https://www.cnblogs.com/dojo-lzz/p/8047336.html</a></p></blockquote><p>2.哪些方式导致内存泄漏</p><blockquote><p>1.意外的全局变量: 无法被回收<br>2.定时器: 未被正确关闭，导致所引用的外部变量无法被释放<br>3.事件监听: 没有正确销毁 (低版本浏览器可能出现)<br>4.闭包: 会导致父级中的变量无法被释放<br>5.dom 引用: dom 元素被删除时，内存中的引用未被正确清空</p></blockquote><p>3.本地存储及区别</p><blockquote><p>这里重点讨论<strong>IndexedDB</strong>和<strong>WebSQL</strong>：参考本文加以理解<a href="http://www.cnblogs.com/ljwsyt/p/9760266.html" target="_blank" rel="noopener">http://www.cnblogs.com/ljwsyt/p/9760266.html</a></p></blockquote><p>4.闭包、作用及处理，垃圾回收器</p><blockquote><p><strong>概念</strong>：1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。<br>　　      2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。<br><strong>作用</strong>：实现封装，管理私有变量和私有方法，将变量（状态）的变化封装在安全的环境中<br><strong>弊端</strong>：让变量始终保持在内存中，不被释放，内存消耗会很大<br><strong>处理</strong>：使用后的变量置为Null，等待垃圾回收器回收</p></blockquote><blockquote><p>垃圾回收器：两种方式：1.<strong>标记清除</strong>（主要）2.<strong>引用计数</strong></p></blockquote><p>5.按需加载（webpack）</p><blockquote><p>参考本文<a href="https://segmentfault.com/a/1190000011519350" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011519350</a></p></blockquote><p>  1.import():<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">         path: &apos;/hello&apos;,</span><br><span class="line">         name: &apos;Hello&apos;,</span><br><span class="line">         // component: Hello</span><br><span class="line">         component: import(/* webpackChunkName: &apos;Hello&apos; */   &apos;../components/Hello&apos;)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>  2.require.ensure()：多个路由指定相同的chunkName，会合并打包成一个js文件。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">         path: &apos;/hello&apos;,</span><br><span class="line">         name: &apos;Hello&apos;,</span><br><span class="line">         // component: Hello</span><br><span class="line">         component: resolve =&gt; require.ensure([], () =&gt; resolve(require(&apos;../components/Hello&apos;)), &apos;demo&apos;)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>6.阻止冒泡</p><blockquote><p>event.stopPropagation()</p></blockquote><p>7.css动画和js动画的区别</p><blockquote><p>参考本文<a href="https://www.cnblogs.com/simba-lkj/p/6139066.html" target="_blank" rel="noopener">https://www.cnblogs.com/simba-lkj/p/6139066.html</a></p></blockquote><p>8.cdn的原理，哪些东西可以使用cdn</p><blockquote><p>  <strong>介绍</strong>：经策略性部署的整体系统，解决由于<strong>网络带宽小、用户访问量大、网点分布不均而产生的用户访问网站响应速度慢</strong>的问题。</p></blockquote><blockquote><p>  <strong>目的</strong>:在现有的Internet中增加一层新的网络架构，将网站的内容发布到<strong>最接近用户</strong>的网络“边缘”，使用户可以<strong>就近</strong>取得所需的内容，<strong>解决 Internet 网络拥塞状况，提高用户访问网站的响应速度。</strong></p></blockquote><p>9.深拷贝和浅拷贝的区别</p><blockquote><p>参考本文<a href="https://www.cnblogs.com/echolun/p/7889848.html" target="_blank" rel="noopener">https://www.cnblogs.com/echolun/p/7889848.html</a></p></blockquote><blockquote><p>浅拷贝：一层遍历和Object.assign()</p></blockquote><blockquote><p>深拷贝主要针对<strong>引用类型</strong>,拷贝<strong>所有层级</strong>的属性</p></blockquote><ul><li><p>方法一：递归实现深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let objClone = Array.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    if(obj &amp;&amp; typeof obj===&quot;object&quot;)&#123;</span><br><span class="line">        for(key in obj)&#123;</span><br><span class="line">            if(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                //判断ojb子元素是否为对象，如果是，递归复制</span><br><span class="line">                if(obj[key]&amp;&amp;typeof obj[key] ===&quot;object&quot;)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //如果不是，简单复制</span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return objClone;</span><br><span class="line">&#125;    </span><br><span class="line">let a=[1,2,3,4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=2;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure></li><li><p>方法二：JSON.Parse和JSON.stringify（兼容ie8+，对于<strong>正则表达式类型和函数类型</strong>无法深拷贝，会直接丢失相应的值,而且会抛弃<strong>对象的constructer</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let _obj = JSON.stringify(obj),</span><br><span class="line">        objClone = JSON.parse(_obj);</span><br><span class="line">    return objClone</span><br><span class="line">&#125;    </span><br><span class="line">let a=[0,1,[2,3],4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=1;</span><br><span class="line">a[2][0]=1;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure></li></ul><p>10.Map和WeakMap与Object</p><blockquote><p>ES6新的数据结构，更为完善的hash结构<br>与Object的区别：Map的键可以是个各种类型的数值，但Object只能是字符串类型或Symbol类型<br>Map与WeakMap的区别：WeakMap只接受对象作为键名，键名是对象的弱引用，当对象被回收后，WeakMap自动移除对应的键值对，WeakMap结构有助于防止内存泄漏。 </p></blockquote><h1 id="Set和WeakSet"><a href="#Set和WeakSet" class="headerlink" title="Set和WeakSet"></a>Set和WeakSet</h1><blockquote><p>Set集合，没有重复元素的集合,WeakSet的键必须为对象，与WeakMap类似</p></blockquote><p>11.有哪几种继承</p><blockquote><p>1.原型链继承：将父类的实例作为子类的原型<br>  2.构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）<br>  3.实例继承：为父类实例添加新特性，作为子类实例返回<br>  4.拷贝继承<br>  5.组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用<br>  6.寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点<br>  7.ES6的Class继承</p></blockquote><p>12.跨越的处理方案</p><blockquote><p>  1、 通过jsonp跨域 （只支持get）<br>    2、 document.domain + iframe跨域（仅限主域相同，子域不同的跨域应用场景）<br>    3、 window.name + iframe跨域<br>    –  3.1name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br>    4、 postMessage跨域<br>    5、 跨域资源共享（CORS）<code>Access-Control-Allow-Origin</code><br>    –  5.1普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，<br>    –  5.2若要带cookie请求：前后端都需要设置。<br>    6、 nginx代理跨域<br>    7、 nodejs中间件代理跨域<br>    8、 Vue跨域：(proxy)</p></blockquote><p>13.重绘和回流<br>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少</p><p>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:</p><p>15.性能优化</p><blockquote><p>1.一些常用压缩方式<br>2.服务器缓存策略</p><ul><li>Cache-Control/Expires:浏览器判断缓存是否过期，未过期时，直接使用强缓存，<strong>如果同时出现，Cache-Control的 max-age 优先级高于 Expires</strong></li></ul></blockquote><ul><li>协商缓存：唯一标识<code>Etag</code>和<code>If-None-Match</code>、最后一次修改时间<code>Last-Modified</code>和<code>If-Modified-Since</code>（Etag优先级高于Lst-Modifieds）</li></ul><p>16.jsonp的原理以及为什么不是真正的ajax</p><p>17.lazyload的原理</p><p>19.sea和require的区别、优缺点</p><blockquote><p>最大的区别：SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行<br>  RequireJS:（1）实现js文件的异步加载，避免网页失去响应；<br>            （2）管理模块之间的依赖性，便于代码的编写和维护。  </p></blockquote><p>21.web worker</p><blockquote><p>简而言之就是子线程，本质就是数据刷新和页面渲染不产生冲突，可通过自带的<strong>消息机制</strong>进行通信但是弊端是兼容性不好，而且无法达到像websocket轮询的效果</p></blockquote><h1 id="！！！"><a href="#！！！" class="headerlink" title="！！！"></a>！！！</h1><p>22.箭头函数什么情况下不能用(<strong>需要动态上下文的场景</strong>)</p><blockquote><p>1.定义对象方法<br>2.定义原型方法<br>3.定义事件回调函数<br>4.定义构造函数<br>5.刻意追求过短的代码，可能会给代码阅读和逻辑理解带来困难。</p></blockquote><p>23.rem和em的区别</p><blockquote><p>区别：rem是基于<strong>html元素的字体大小</strong>来决定，而em则根据<strong>使用它的元素的大小</strong>决定（很多人错误以为是根据父类元素，实际上是使用它的元素继承了父类的属性才会产生的错觉）</p></blockquote><blockquote><p><strong>举例</strong>：<br>    当使用 rem 单位，他们转化为像素大小取决于页根元素的字体大小，即 html 元素的字体大小。 根元素字体大小乘以你 rem 值。<br>    例如，根元素的字体大小 16px，10rem 将等同于 160px，即 10 x 16 = 160。 </p></blockquote><blockquote><p>  当使用em单位时，像素值将是em值乘以使用em单位的元素的字体大小。<br>    弊端：继承</p></blockquote><p>24.移动端适配</p><blockquote><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot;&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>2.手淘团队flexible.js布局</p></blockquote><p>25.数组如何去重（ES5,ES6）</p><blockquote><p>1.ES6中新增了<strong>Set数据结构</strong>，类似于数组，但是 它的成员都是<strong>唯一</strong>的 ，其构造函数可以接受一个数组作为参数<br>2.ES6中Array新增了一个静态方法<strong>Array.from</strong>，可以把<strong>类似数组的对象</strong>转换为<strong>数组</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ES6:</span><br><span class="line">let array = [1,2,3,4,4,2,1,5];</span><br><span class="line">let res = Array.from(new Set(array))</span><br><span class="line">console.log(res)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ES5方法一</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">        //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span><br><span class="line">        return arr.indexOf(item, 0) === index</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ES5方法二</span><br><span class="line">function uniqueArr(arr)&#123;</span><br><span class="line">    var arr2 = []</span><br><span class="line">    var len = arr.length</span><br><span class="line">    for(var i=0;i&lt;len; i++) &#123;</span><br><span class="line">        if(arr2.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">            arr2.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>26.函数柯里化</p><blockquote><p>柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。<br>详情参考<a href="https://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="noopener">https://www.jianshu.com/p/5e1899fe7d6b</a></p></blockquote><p>27.vue的虚拟dom原理是什么？怎么实现的？！！！！！！！！！！！！！难以理解</p><blockquote><p>js创建dom，diff算法，同级比较</p></blockquote><p>28.http请求头里都有什么内容</p><ul><li>Accept:浏览器能够处理的内容类型</li><li>Accept-Charset:浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URL</li><li>User-Agent：浏览器的用户代理字符串</li></ul><p>29.常用状态码</p><blockquote><ul><li>200: 成功，并返回数据<ul><li>302: 临时重定向</li><li>304: 资源未修改，可使用缓存</li><li>403: 拒绝请求</li><li>404: 资源不存在</li><li>500: 服务器错误</li></ul></li></ul></blockquote><p>29.promise顺序执行 </p><blockquote><p>方法一:  then()执行<br>方法二： 使用队列执行<br>方法三： 使用async、await实现类似同步编程</p></blockquote><p>30.Event loop</p><blockquote><p>首先放上参考文章，非常推荐，简单明了！！！<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">https://juejin.im/post/59e85eebf265da430d571f89</a></p></blockquote><blockquote><p>概念： 简单来讲就是时间循环机制（废话，哈哈哈哈哈～～～～）</p></blockquote><p>  首先看一下下面这张图，有助于理解js是如何运行的<br><img src="/2019/01/24/Interview-Questions/eventloop.png" title="eventloop"></p><p>上图表达的意思就是：👇👇👇</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，（js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。）会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，IO，setTimeout，setInterval</li><li>micro-task(微任务)：Promise中的回调（Promise自身是宏任务，不知是否可以这么理解），process.nextTick<img src="/2019/01/24/Interview-Questions/task-step.png" title="task-step"></li></ul><p>30.call apply bind区别和用法</p><blockquote><p>都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）；<br>apply的<strong>第二个参数</strong>是一个<strong>数组</strong>，call第二个及以后的参数都是数组中的元素<br>bind与apply、call<strong>最大的区别</strong>就是：bind不会立即调用，其他两个会立即调用   </p></blockquote><p>31.<strong>THIS</strong>（<strong>看完你就明白了</strong>）</p><blockquote><p>this 就是你 call 一个函数时，传入的第一个参数。（请务必背下来「this 就是 call 的第一个参数」）<br>参考本文，一看就懂<a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23804247</a></p></blockquote><p>32.原型与原型链</p><blockquote><p><strong>原型链</strong>:在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条<br><strong>原理</strong>：当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。<br><strong>方法</strong>：使用对象的hasOwnProperty()来检查对象自身是否含有该属性，使用in来检查是否在整条原型链上是否含有该属性<br><strong>注意点</strong>：Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有<strong>proto</strong>这个属性。</p></blockquote><blockquote><p>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外）<br>  所有的引用类型（数组、对象、函数），都有一个<strong>proto</strong>属性，属性值是一个普通的对象<br>  所有的函数，都有一个prototype属性，属性值也是一个普通的对象<br>  所有的引用类型（数组、对象、函数），<strong>proto</strong>属性值指向它的构造函数的prototype属性值</p></blockquote><p>33.GraphQL</p><blockquote><p>详情请关注官网链接<a href="http://graphql.cn/" target="_blank" rel="noopener">http://graphql.cn/</a><br><strong>概念</strong>：一种用于 API 的查询语言，代替rest api</p></blockquote><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>1.冒泡排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> function bubleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (let i = len ; i &gt;= 2;i--) &#123;</span><br><span class="line">        for(let j = 0; j &lt;= i - 1; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">               // [arr[j],arr[j+1]] = [arr[j+1],arr[j]]</span><br><span class="line">                let tmp = arr[j+1]</span><br><span class="line">                arr[j+1] = arr[j]</span><br><span class="line">                arr[j] = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.快速排序<br>原理：选一个数，比较大小，放在当前数的左右数组，最后递归左右数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if(arr.length &lt;= 1) &#123;</span><br><span class="line">        return arr;  //递归出口</span><br><span class="line">    &#125;</span><br><span class="line">    var left = [],</span><br><span class="line">        right = [],</span><br><span class="line">        current = arr.splice(0,1); </span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(arr[i] &lt; current) &#123;</span><br><span class="line">            left.push(arr[i])  //放在左边</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(arr[i]) //放在右边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return quickSort(left).concat(current,quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文只记录面试过程中遇到的面试题(不定更)，答案请自行百度(自己动手、丰衣足食)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;框架知识&quot;&gt;&lt;a href=&quot;#框架知识&quot; class=&quot;headerlink&quot; title=&quot;框架知识&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>When to use var vs let vs const in JavaScript</title>
    <link href="http://yoursite.com/2019/01/21/When%20to%20use%20var%20vs%20let%20vs%20const%20in%20JavaScript/"/>
    <id>http://yoursite.com/2019/01/21/When to use var vs let vs const in JavaScript/</id>
    <published>2019-01-21T14:45:06.000Z</published>
    <updated>2019-01-30T07:23:17.404Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考</p><p><a href="https://medium.freecodecamp.org/var-vs-let-vs-const-in-javascript-2954ae48c037" target="_blank" rel="noopener">https://medium.freecodecamp.org/var-vs-let-vs-const-in-javascript-2954ae48c037</a></p><p>在这篇文章中，你将会在javascript（ES6）中学习两种新的方式创建变量，let和const。在此过程中，我们将看到var，let和const的不同之处，以及包括诸如函数与块作用域、变量提升和不变性等主题</p><p>ES2015（或者ES6）介绍了两种新的方式创建变量，let和const。但是在我们真正区分var,let和const不同点之前，你应该先了解一些前提条件。它们是变量声明vs初始化，作用域（特别是函数作用域），和变量提升</p><h1 id="变量声明vs初始化"><a href="#变量声明vs初始化" class="headerlink" title="变量声明vs初始化"></a>变量声明vs初始化</h1><p>一个变量声明介绍了一个新的标识符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var declaration</span><br></pre></td></tr></table></figure><p>上面我们创建了一个新的标识符叫做声明。在javascript中，当变量被创建，它们以undefined的值被初始化。这意味着，如果我们尝试打印声明的变量，我们将得到undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var declaration</span><br><span class="line">console.log(declaration)</span><br></pre></td></tr></table></figure><p>所以如果我们打印声明的变量，我们得到undefined</p><p>与变量声明相反，变量初始化是指当你首次给一个变量赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var declaration</span><br><span class="line">console.log(declaration) // undefined</span><br><span class="line">declaration = &apos;This is an initialization&apos;</span><br></pre></td></tr></table></figure><p>所以在这里我们通过赋值给已经声明当变量一个字符串来初始化它。</p><p>这就引导我们第二个概念了，作用域</p><h1 id="Scope-作用域"><a href="#Scope-作用域" class="headerlink" title="Scope(作用域)"></a>Scope(作用域)</h1><p>作用域定义了在你的程序里，变量和函数在哪里可以获取到。在JavaScript中，有两种类型的作用域–全局作用域和函数作用域，根据官方的规范</p><p>如果变量语句发生在函数声明中，则变量在这个函数中通过函数局部作用域来定义</p><p>这就意味着如果你使用var来创建一个函数，那么这个变量被运用于它所创建的函数，并且只能在该函数内部或者任何嵌套函数内部被访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getDate () &#123;</span><br><span class="line">  var date = new Date()</span><br><span class="line">  return date</span><br><span class="line">&#125;</span><br><span class="line">getDate()</span><br><span class="line">console.log(date) // ❌ Reference Error</span><br></pre></td></tr></table></figure><p>上面我们尝试获取一个被声明的函数之外的变量。因为date是作用域于getDate的函数，它只能被getDate它本身或者getDate中的任何嵌套函数所获取（如下所示）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getDate()&#123;</span><br><span class="line">    var date = new Date()</span><br><span class="line">    function formatDate()&#123;</span><br><span class="line">        return date.toDateString().slice(4) //可获取</span><br><span class="line">    &#125;</span><br><span class="line">    return formatDate()</span><br><span class="line">&#125;</span><br><span class="line">getDate()</span><br><span class="line">console.log(date) // Reference Error 引用错误</span><br></pre></td></tr></table></figure></p><p>现在让我们来看一个更高级的例子。假设我们有一个prices的数组，并且我们需要一个函数，这个函数接收一个像折扣的数组，并且返回一个折扣后的新数组。最后的目标可能看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discountPrices([100, 200, 300], .5)</span><br></pre></td></tr></table></figure><p>并且实现可能看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  var discounted = []  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好像很简单，但是这与块作用域有什么关系？看一下这个for循环，它声明的变量是否可以在它外部被访问呢？事实证明，是可以的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  var discounted = []  </span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果JavaScript是你所了解的唯一一个编程语言，你可能不会想什么。然而，如果你从另一门编程语言（特别是这门语言是封闭的作用域）开始使用JavaScript，那么你很可能对这发生对事情感到有点担心。</p><p>它没有真正的破碎，他只是有点怪异。在for循环之外，这没有一个理由仍然能够访问到i，discountedPrice，和finalPrice。它不会对我们有任何的好处，并且甚至可能在一定程度上对我们造成伤害。然而，因为用var声明的变量是函数作用域的，所以你可以这样做。</p><p>现在我们已经可以讨论过变量声明，初始化，和作用域，那么在我们深入了解let和const之前我们需要清除的最后一件事就是提升。</p><h1 id="Hoisting（提升）"><a href="#Hoisting（提升）" class="headerlink" title="Hoisting（提升）"></a>Hoisting（提升）</h1><p>记得早的时候我们说过，‘在JavaScript中，变量被创建时可以用undefined值来初始化。事实证明，这就是“Hoisting”的全部。JavaScript解析器在被“创建”的阶段将分配一个默认的值undefined给变量的声明。</p><blockquote><p>For a much more in depth guide on the Creation Phase, Hoisting, and Scopes see “The Ultimate Guide to Hoisting, Scopes, and Closures in JavaScript”.</p></blockquote><p>寻找更多更深入关于创建阶段，提升和作用域的指南，可以参阅 The Ultimate Guide to Hoisting, Scopes, and Closures in JavaScript</p><p>让我们看一下之前的例子和提升是如何影响它的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  var discounted = undefined</span><br><span class="line">  var i = undefined</span><br><span class="line">  var discountedPrice = undefined</span><br><span class="line">  var finalPrice = undefined  </span><br><span class="line">      discounted = []</span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125; </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意所有声明的变量都被分配一个默认的值undefined。这就是为什么如果你在变量被真正声明之前访问其中一个变量，你仅仅得到undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  console.log(discounted) // undefined  </span><br><span class="line">  var discounted = []  </span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在你已经知道了有关var的每一件事，让我们最后讨论你为什么在这的重点：var，let和const的区别在哪里？</p><h1 id="var-VS-let-VS-const"><a href="#var-VS-let-VS-const" class="headerlink" title="var VS let VS const"></a>var VS let VS const</h1><p>首先，让我们比较var和let。var和let主要的不同点不是函数作用域，let是块作用域。</p><p>这就意味着一个变量用let关键字创建可以被“块”内部以及任何嵌套的块中所访问。当我说“块”时，我是指像在一个for循环或者一个if语句中用一个大括号{}包围起来的任何东西</p><p>所以让我们最后一次回顾下我们的discountPrices函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  var discounted = []  </span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记住我们能够在for循环之外打印i，discountedPrice和finalPrice，因为它们被var声明，并且var是一个函数作用域，但是现在，如果我们改变这些var声明，使用let声明，并且尝试运行它，会发生什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  let discounted = []  </span><br><span class="line">  for (let i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    let discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    let finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br><span class="line">discountPrices([100, 200, 300], .5) // ❌ ReferenceError: i is not defined</span><br></pre></td></tr></table></figure></p><p>我们得到ReferenceError: i is not defined.这告诉我们的是，用let声明变量是块作用域而不是函数作用域。所以尝试在它们声明的“块”之外访问i（或者discountedPrice or finalPrice）将给我们一个引用错误，正如我们刚才所看到的。</p><h1 id="var-VS-let"><a href="#var-VS-let" class="headerlink" title="var VS let"></a>var VS let</h1><blockquote><p>var: function scopedlet: block scoped</p></blockquote><p>下一个区别与提升相关。之前我们说过，提升的定义是“JavaScript解析器将在“创建”阶段分配声明的变量一个默认值undefined”我们甚至在声明变量之前通过打印一个变量看到了这个行为（你得到了undefined）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  console.log(discounted) // undefined  </span><br><span class="line">  var discounted = []  </span><br><span class="line">  for (var i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    var discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    var finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我想不到任何你想要在声明变量之前访问变量的案例。这看起来就像抛出一个引用错误也比返回undefined更好</p><p>事实上，这就是let做的事情。如果你尝试在声明之前访问一个用let声明过的变量，而不是得到undefined（就像用var声明那些变量），你将得到一个引用错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function discountPrices (prices, discount) &#123;</span><br><span class="line">  console.log(discounted) // ❌ ReferenceError  </span><br><span class="line">  let discounted = []  </span><br><span class="line">  for (let i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">    let discountedPrice = prices[i] * (1 - discount)</span><br><span class="line">    let finalPrice = Math.round(discountedPrice * 100) / 100</span><br><span class="line">    discounted.push(finalPrice)</span><br><span class="line">  &#125;  </span><br><span class="line">  console.log(i) // 3</span><br><span class="line">  console.log(discountedPrice) // 150</span><br><span class="line">  console.log(finalPrice) // 150  </span><br><span class="line">  return discounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="var-VS-let-1"><a href="#var-VS-let-1" class="headerlink" title="var VS let"></a>var VS let</h1><blockquote><p>var: function scoped<br>      undefined when accessing a variable before it’s declared</p></blockquote><blockquote><p>let: block scoped<br>    ReferenceError when accessing a variable before it’s declared</p></blockquote><h1 id="let-VS-const"><a href="#let-VS-const" class="headerlink" title="let VS const"></a>let VS const</h1><p>现在你理解了var和let的区别，那么const呢？事实上，const更像是let，然而，唯一的不同点就是你一旦用const分配了一个变量的值，你将不能重新分配一个新的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;Tyler&apos;</span><br><span class="line">const handle = &apos;tylermcginnis&apos;</span><br><span class="line">      name = &apos;Tyler McGinnis&apos; // ✅</span><br><span class="line">handle = &apos;@tylermcginnis&apos; // ❌ TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></p><p>上面的内容用let声明的变量可以重新赋值，但是用const声明的变量不能</p><p>非常酷，所以你只要想一个变量永远不变，你可以用const来声明。当然也不完全，仅仅因为用const声明一个变量并不意味着它是永远不变的，这完全意味着值不能被重新赋值。这就是一个很好的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &apos;Kim Kardashian&apos;</span><br><span class="line">&#125;</span><br><span class="line">person.name = &apos;Kim Kardashian West&apos; // ✅</span><br><span class="line">person = &#123;&#125; // ❌ Assignment to constant variable.</span><br></pre></td></tr></table></figure></p><p>注意，在一个对象上改变一个属性并不是重新赋值，所以即使一个对象用const声明，也不意味着你不能改变它的属性。这仅仅意味你不能重新分配一个新值</p><p>现在我们还没有回答最重要的问题是：你应该使用var，let或者const？最受欢迎的观点和我表述的观点是，你应该总是使用const，除非你知道变量将发生改变。这么做的原因是使用const，你向未来的自己以及必须阅读你代码的任何未来的开发者们发出信号，这个变量不应该改变。如果它将需要改变（像在for循环中），你应该使用let</p><p>所以，在可变的变量与不可改变的变量之间，就没有太多的东西剩下。这意味着你不应该再使用var</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>var是函数作用域，并且如果你尝试在实际声明之前使用一个var声明的变量，你将得到undefined。</p><p>const和let是块作用域，并且如果你尝试在实际声明之前使用let或const声明的变量，你将得到一个引用错误。</p><p>最后在let和const之间的区别是一旦你用const分配了一个值，你将不行重新赋值，但是用let可以</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.freecodecamp.org/var-vs-let-vs-const-in-javascript-2954ae48c037&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My Introduction</title>
    <link href="http://yoursite.com/2019/01/21/My-Introduction/"/>
    <id>http://yoursite.com/2019/01/21/My-Introduction/</id>
    <published>2019-01-21T14:04:39.000Z</published>
    <updated>2019-01-30T07:02:34.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>昨天，永远属于过去，昨天，如一颗陨落的流星划过天际，来不及招呼。</p><p>回望昨天，已是过去，过去早已不再清晰，变得模糊。</p><p>因此每一个昨天，都值得被记录下来。</p><p>从今天开始，记录也就开始了～～～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyIntroduction: &#123;</span><br><span class="line">  name: &quot;LJTin&quot;,</span><br><span class="line">  Job: &quot;Front End Engineer&quot;,</span><br><span class="line">  GraduationTime: 2016,</span><br><span class="line">  Hobbies: [&quot;交友&quot;, &quot;瞎折腾&quot;, &quot;学习&quot;],</span><br><span class="line">  MainTech: [&quot;Vue&quot;, &quot;React&quot;, &quot;Node&quot;, &quot;Koa&quot;, &quot;Express&quot;, &quot;mpvue&quot;, &quot;小程序&quot;],</span><br><span class="line">  SecondaryTech:[&quot;linux&quot;, &quot;python&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果各位大佬看到了这里，那么有猿千里来相会吧：</p><p>  email：<a href="mailto:jiantinglian619@gmail.com" target="_blank" rel="noopener">jiantinglian619@gmail.com</a><br>  wechat：ai562751028</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;昨天，永远属于过去，昨天，如一颗陨落的流星划过天际，来不及招呼。&lt;/p&gt;
&lt;p&gt;回望昨天，已是过去，过去早已不再清晰，变得模糊。&lt;/
      
    
    </summary>
    
    
  </entry>
  
</feed>
