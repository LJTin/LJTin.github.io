<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Interview-Questions · LJTin's Blog</title><meta name="description" content="Interview-Questions - LJTin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="LJTin's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://juejin.im/user/5be564e2f265da615d7226e5" target="_blank" class="nav-list-link">JUEJIN</a></li><li class="nav-list-item"><a href="https://github.com/LJTin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/2019/01/21/My-Introduction/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Interview-Questions</h1><div class="post-info">Jan 24, 2019</div><div class="post-content"><blockquote>
<p>本文只记录面试过程中遇到的面试题(不定更)，答案请自行百度(自己动手、丰衣足食)</p>
</blockquote>
<h1 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h1><p>1.谈谈对ssr的了解</p>
<blockquote>
<p>seo与首屏渲染快<br>比较适合首屏使用ssr进行快速渲染，更利于seo</p>
</blockquote>
<p>2.react和vue的区别</p>
<blockquote>
<p><strong>react</strong>:<br>1.all in js<br>        2.函数式<br>        3.单向数据流</p>
</blockquote>
<blockquote>
<p><strong>vue</strong>:<br>1.html css js在一个文件下<br>     2.响应式<br>     3.双向绑定</p>
</blockquote>
<p>3.vue数据驱动的原理</p>
<blockquote>
<p>1.vue在实例化过程中，遍历data所有的属性并使用Object.defineProperty将属性全转化为getter/setter<br>2.每个实例对象都有一个watcher，在模板编译过程中使用getter访问data的属性，并且标记为依赖，建立视图与数据的联系<br>3.当依赖的数据发生了变化，就调用了setter方法，watcher会对比前后两个值的变化，决定是否通知视图重新渲染</p>
</blockquote>
<p>4.v-if和v-show的区别</p>
<blockquote>
<p>1.DOM差异，CSS差异</p>
</blockquote>
<p>5.Proxy 相比于 defineProperty 的优势</p>
<blockquote>
<ul>
<li>数组变化也能监听到<ul>
<li>不需要深度遍历监听</li>
</ul>
</li>
</ul>
</blockquote>
<p>6.nextTick()</p>
<blockquote>
<p>官方解释：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
</blockquote>
<blockquote>
<p>何时使用：(DOM发生变化的操作（不严谨！！！具体看下面两个例子👇👇👇）)</p>
<ul>
<li>1.在created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。<br><strong>原因</strong>：是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，所以一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。mounted该钩子函数执行时所有的DOM挂载和渲染都已完成，因此不需要使用nextTick()。</li>
</ul>
</blockquote>
<ul>
<li>2.在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放进Vue.nextTick()的回调函数中。</li>
</ul>
<p>7.vue的生命周期</p>
<blockquote>
<p>参考本文，个人感觉写的比较详细了 <a href="https://segmentfault.com/a/1190000011381906" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011381906</a><br>也可参考本文，讲的比较精干<a href="https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-60" target="_blank" rel="noopener">https://juejin.im/post/5c64d15d6fb9a049d37f9c20#heading-60</a></p>
</blockquote>
<p>8.beforeCreate和Created的区别：</p>
<blockquote>
<p>beforeCreate 获取不到el和data<br>Created 获取的到data，但获取不到el（mounted中可获取）</p>
</blockquote>
<h1 id="Git知识"><a href="#Git知识" class="headerlink" title="Git知识"></a>Git知识</h1><p>1.git中rebase是做什么的，有何意义</p>
<blockquote>
<p>把提交的记录变得流畅</p>
</blockquote>
<h1 id="非框架知识"><a href="#非框架知识" class="headerlink" title="非框架知识"></a>非框架知识</h1><p>1.serviceworker</p>
<blockquote>
<p>参考本文<a href="https://www.cnblogs.com/dojo-lzz/p/8047336.html" target="_blank" rel="noopener">https://www.cnblogs.com/dojo-lzz/p/8047336.html</a></p>
</blockquote>
<p>2.哪些方式导致内存泄漏</p>
<blockquote>
<p>1.意外的全局变量: 无法被回收<br>2.定时器: 未被正确关闭，导致所引用的外部变量无法被释放<br>3.事件监听: 没有正确销毁 (低版本浏览器可能出现)<br>4.闭包: 会导致父级中的变量无法被释放<br>5.dom 引用: dom 元素被删除时，内存中的引用未被正确清空</p>
</blockquote>
<p>3.本地存储及区别</p>
<blockquote>
<p>这里重点讨论<strong>IndexedDB</strong>和<strong>WebSQL</strong>：参考本文加以理解<a href="http://www.cnblogs.com/ljwsyt/p/9760266.html" target="_blank" rel="noopener">http://www.cnblogs.com/ljwsyt/p/9760266.html</a></p>
</blockquote>
<p>4.闭包、作用及处理，垃圾回收器</p>
<blockquote>
<p><strong>概念</strong>：1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。<br>　　      2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。<br><strong>作用</strong>：实现封装，管理私有变量和私有方法，将变量（状态）的变化封装在安全的环境中<br><strong>弊端</strong>：让变量始终保持在内存中，不被释放，内存消耗会很大<br><strong>处理</strong>：使用后的变量置为Null，等待垃圾回收器回收</p>
</blockquote>
<blockquote>
<p>垃圾回收器：两种方式：1.<strong>标记清除</strong>（主要）2.<strong>引用计数</strong></p>
</blockquote>
<p>5.按需加载（webpack）</p>
<blockquote>
<p>参考本文<a href="https://segmentfault.com/a/1190000011519350" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011519350</a></p>
</blockquote>
<p>  1.import():<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">         path: &apos;/hello&apos;,</span><br><span class="line">         name: &apos;Hello&apos;,</span><br><span class="line">         // component: Hello</span><br><span class="line">         component: import(/* webpackChunkName: &apos;Hello&apos; */   &apos;../components/Hello&apos;)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>  2.require.ensure()：多个路由指定相同的chunkName，会合并打包成一个js文件。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">         path: &apos;/hello&apos;,</span><br><span class="line">         name: &apos;Hello&apos;,</span><br><span class="line">         // component: Hello</span><br><span class="line">         component: resolve =&gt; require.ensure([], () =&gt; resolve(require(&apos;../components/Hello&apos;)), &apos;demo&apos;)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>6.阻止冒泡</p>
<blockquote>
<p>event.stopPropagation()</p>
</blockquote>
<p>7.css动画和js动画的区别</p>
<blockquote>
<p>参考本文<a href="https://www.cnblogs.com/simba-lkj/p/6139066.html" target="_blank" rel="noopener">https://www.cnblogs.com/simba-lkj/p/6139066.html</a></p>
</blockquote>
<p>8.cdn的原理，哪些东西可以使用cdn</p>
<blockquote>
<p>  <strong>介绍</strong>：经策略性部署的整体系统，解决由于<strong>网络带宽小、用户访问量大、网点分布不均而产生的用户访问网站响应速度慢</strong>的问题。</p>
</blockquote>
<blockquote>
<p>  <strong>目的</strong>:在现有的Internet中增加一层新的网络架构，将网站的内容发布到<strong>最接近用户</strong>的网络“边缘”，使用户可以<strong>就近</strong>取得所需的内容，<strong>解决 Internet 网络拥塞状况，提高用户访问网站的响应速度。</strong></p>
</blockquote>
<p>9.深拷贝和浅拷贝的区别</p>
<blockquote>
<p>参考本文<a href="https://www.cnblogs.com/echolun/p/7889848.html" target="_blank" rel="noopener">https://www.cnblogs.com/echolun/p/7889848.html</a></p>
</blockquote>
<blockquote>
<p>浅拷贝：一层遍历和Object.assign()</p>
</blockquote>
<blockquote>
<p>深拷贝主要针对<strong>引用类型</strong>,拷贝<strong>所有层级</strong>的属性</p>
</blockquote>
<ul>
<li><p>方法一：递归实现深拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let objClone = Array.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">    if(obj &amp;&amp; typeof obj===&quot;object&quot;)&#123;</span><br><span class="line">        for(key in obj)&#123;</span><br><span class="line">            if(obj.hasOwnProperty(key))&#123;</span><br><span class="line">                //判断ojb子元素是否为对象，如果是，递归复制</span><br><span class="line">                if(obj[key]&amp;&amp;typeof obj[key] ===&quot;object&quot;)&#123;</span><br><span class="line">                    objClone[key] = deepClone(obj[key]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //如果不是，简单复制</span><br><span class="line">                    objClone[key] = obj[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return objClone;</span><br><span class="line">&#125;    </span><br><span class="line">let a=[1,2,3,4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=2;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：JSON.Parse和JSON.stringify（兼容ie8+，对于<strong>正则表达式类型和函数类型</strong>无法深拷贝，会直接丢失相应的值,而且会抛弃<strong>对象的constructer</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let _obj = JSON.stringify(obj),</span><br><span class="line">        objClone = JSON.parse(_obj);</span><br><span class="line">    return objClone</span><br><span class="line">&#125;    </span><br><span class="line">let a=[0,1,[2,3],4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=1;</span><br><span class="line">a[2][0]=1;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>10.Map和WeakMap与Object</p>
<blockquote>
<p>ES6新的数据结构，更为完善的hash结构<br>与Object的区别：Map的键可以是个各种类型的数值，但Object只能是字符串类型或Symbol类型<br>Map与WeakMap的区别：WeakMap只接受对象作为键名，键名是对象的弱引用，当对象被回收后，WeakMap自动移除对应的键值对，WeakMap结构有助于防止内存泄漏。 </p>
</blockquote>
<h1 id="Set和WeakSet"><a href="#Set和WeakSet" class="headerlink" title="Set和WeakSet"></a>Set和WeakSet</h1><blockquote>
<p>Set集合，没有重复元素的集合,WeakSet的键必须为对象，与WeakMap类似</p>
</blockquote>
<p>11.有哪几种继承</p>
<blockquote>
<p>1.原型链继承：将父类的实例作为子类的原型<br>  2.构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）<br>  3.实例继承：为父类实例添加新特性，作为子类实例返回<br>  4.拷贝继承<br>  5.组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用<br>  6.寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点<br>  7.ES6的Class继承</p>
</blockquote>
<p>12.跨越的处理方案</p>
<blockquote>
<p>  1、 通过jsonp跨域 （只支持get）<br>    2、 document.domain + iframe跨域（仅限主域相同，子域不同的跨域应用场景）<br>    3、 window.name + iframe跨域<br>    –  3.1name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br>    4、 postMessage跨域<br>    5、 跨域资源共享（CORS）<code>Access-Control-Allow-Origin</code><br>    –  5.1普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，<br>    –  5.2若要带cookie请求：前后端都需要设置。<br>    6、 nginx代理跨域<br>    7、 nodejs中间件代理跨域<br>    8、 Vue跨域：(proxy)</p>
</blockquote>
<p>13.重绘和回流<br>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少</p>
<p>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:</p>
<p>15.性能优化</p>
<blockquote>
<p>1.一些常用压缩方式<br>2.服务器缓存策略</p>
<ul>
<li>Cache-Control/Expires:浏览器判断缓存是否过期，未过期时，直接使用强缓存，<strong>如果同时出现，Cache-Control的 max-age 优先级高于 Expires</strong></li>
</ul>
</blockquote>
<ul>
<li>协商缓存：唯一标识<code>Etag</code>和<code>If-None-Match</code>、最后一次修改时间<code>Last-Modified</code>和<code>If-Modified-Since</code>（Etag优先级高于Lst-Modifieds）</li>
</ul>
<p>16.jsonp的原理以及为什么不是真正的ajax</p>
<p>17.lazyload的原理</p>
<p>19.sea和require的区别、优缺点</p>
<blockquote>
<p>最大的区别：SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行<br>  RequireJS:（1）实现js文件的异步加载，避免网页失去响应；<br>            （2）管理模块之间的依赖性，便于代码的编写和维护。  </p>
</blockquote>
<p>21.web worker</p>
<blockquote>
<p>简而言之就是子线程，本质就是数据刷新和页面渲染不产生冲突，可通过自带的<strong>消息机制</strong>进行通信但是弊端是兼容性不好，而且无法达到像websocket轮询的效果</p>
</blockquote>
<h1 id="！！！"><a href="#！！！" class="headerlink" title="！！！"></a>！！！</h1><p>22.箭头函数什么情况下不能用(<strong>需要动态上下文的场景</strong>)</p>
<blockquote>
<p>1.定义对象方法<br>2.定义原型方法<br>3.定义事件回调函数<br>4.定义构造函数<br>5.刻意追求过短的代码，可能会给代码阅读和逻辑理解带来困难。</p>
</blockquote>
<p>23.rem和em的区别</p>
<blockquote>
<p>区别：rem是基于<strong>html元素的字体大小</strong>来决定，而em则根据<strong>使用它的元素的大小</strong>决定（很多人错误以为是根据父类元素，实际上是使用它的元素继承了父类的属性才会产生的错觉）</p>
</blockquote>
<blockquote>
<p><strong>举例</strong>：<br>    当使用 rem 单位，他们转化为像素大小取决于页根元素的字体大小，即 html 元素的字体大小。 根元素字体大小乘以你 rem 值。<br>    例如，根元素的字体大小 16px，10rem 将等同于 160px，即 10 x 16 = 160。 </p>
</blockquote>
<blockquote>
<p>  当使用em单位时，像素值将是em值乘以使用em单位的元素的字体大小。<br>    弊端：继承</p>
</blockquote>
<p>24.移动端适配</p>
<blockquote>
<p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>2.手淘团队flexible.js布局</p>
</blockquote>
<p>25.数组如何去重（ES5,ES6）</p>
<blockquote>
<p>1.ES6中新增了<strong>Set数据结构</strong>，类似于数组，但是 它的成员都是<strong>唯一</strong>的 ，其构造函数可以接受一个数组作为参数<br>2.ES6中Array新增了一个静态方法<strong>Array.from</strong>，可以把<strong>类似数组的对象</strong>转换为<strong>数组</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ES6:</span><br><span class="line">let array = [1,2,3,4,4,2,1,5];</span><br><span class="line">let res = Array.from(new Set(array))</span><br><span class="line">console.log(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ES5方法一</span><br><span class="line">function unique(arr) &#123;</span><br><span class="line">    return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">        //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span><br><span class="line">        return arr.indexOf(item, 0) === index</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ES5方法二</span><br><span class="line">function uniqueArr(arr)&#123;</span><br><span class="line">    var arr2 = []</span><br><span class="line">    var len = arr.length</span><br><span class="line">    for(var i=0;i&lt;len; i++) &#123;</span><br><span class="line">        if(arr2.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">            arr2.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26.函数柯里化</p>
<blockquote>
<p>柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。<br>详情参考<a href="https://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="noopener">https://www.jianshu.com/p/5e1899fe7d6b</a></p>
</blockquote>
<p>27.vue的虚拟dom原理是什么？怎么实现的？！！！！！！！！！！！！！难以理解</p>
<blockquote>
<p>js创建dom，diff算法，同级比较</p>
</blockquote>
<p>28.http请求头里都有什么内容</p>
<ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<p>29.常用状态码</p>
<blockquote>
<ul>
<li>200: 成功，并返回数据<ul>
<li>302: 临时重定向</li>
<li>304: 资源未修改，可使用缓存</li>
<li>403: 拒绝请求</li>
<li>404: 资源不存在</li>
<li>500: 服务器错误</li>
</ul>
</li>
</ul>
</blockquote>
<p>29.promise顺序执行 </p>
<blockquote>
<p>方法一:  then()执行<br>方法二： 使用队列执行<br>方法三： 使用async、await实现类似同步编程</p>
</blockquote>
<p>30.Event loop</p>
<blockquote>
<p>首先放上参考文章，非常推荐，简单明了！！！<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">https://juejin.im/post/59e85eebf265da430d571f89</a></p>
</blockquote>
<blockquote>
<p>概念： 简单来讲就是时间循环机制（废话，哈哈哈哈哈～～～～）</p>
</blockquote>
<p>  首先看一下下面这张图，有助于理解js是如何运行的<br><img src="/2019/01/24/Interview-Questions/eventloop.png" title="eventloop"></p>
<p>上图表达的意思就是：👇👇👇</p>
<ul>
<li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，（js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。）会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<ul>
<li>macro-task(宏任务)：包括整体代码script，IO，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise中的回调（Promise自身是宏任务，不知是否可以这么理解），process.nextTick<img src="/2019/01/24/Interview-Questions/task-step.png" title="task-step">
</li>
</ul>
<p>30.call apply bind区别和用法</p>
<blockquote>
<p>都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）；<br>apply的<strong>第二个参数</strong>是一个<strong>数组</strong>，call第二个及以后的参数都是数组中的元素<br>bind与apply、call<strong>最大的区别</strong>就是：bind不会立即调用，其他两个会立即调用   </p>
</blockquote>
<p>31.<strong>THIS</strong>（<strong>看完你就明白了</strong>）</p>
<blockquote>
<p>this 就是你 call 一个函数时，传入的第一个参数。（请务必背下来「this 就是 call 的第一个参数」）<br>参考本文，一看就懂<a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23804247</a></p>
</blockquote>
<p>32.原型与原型链</p>
<blockquote>
<p><strong>原型链</strong>:在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条<br><strong>原理</strong>：当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。<br><strong>方法</strong>：使用对象的hasOwnProperty()来检查对象自身是否含有该属性，使用in来检查是否在整条原型链上是否含有该属性<br><strong>注意点</strong>：Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有<strong>proto</strong>这个属性。</p>
</blockquote>
<blockquote>
<p>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外）<br>  所有的引用类型（数组、对象、函数），都有一个<strong>proto</strong>属性，属性值是一个普通的对象<br>  所有的函数，都有一个prototype属性，属性值也是一个普通的对象<br>  所有的引用类型（数组、对象、函数），<strong>proto</strong>属性值指向它的构造函数的prototype属性值</p>
</blockquote>
<p>33.GraphQL</p>
<blockquote>
<p>详情请关注官网链接<a href="http://graphql.cn/" target="_blank" rel="noopener">http://graphql.cn/</a><br><strong>概念</strong>：一种用于 API 的查询语言，代替rest api</p>
</blockquote>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>1.冒泡排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> function bubleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (let i = len ; i &gt;= 2;i--) &#123;</span><br><span class="line">        for(let j = 0; j &lt;= i - 1; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">               // [arr[j],arr[j+1]] = [arr[j+1],arr[j]]</span><br><span class="line">                let tmp = arr[j+1]</span><br><span class="line">                arr[j+1] = arr[j]</span><br><span class="line">                arr[j] = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.快速排序<br>原理：选一个数，比较大小，放在当前数的左右数组，最后递归左右数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if(arr.length &lt;= 1) &#123;</span><br><span class="line">        return arr;  //递归出口</span><br><span class="line">    &#125;</span><br><span class="line">    var left = [],</span><br><span class="line">        right = [],</span><br><span class="line">        current = arr.splice(0,1); </span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if(arr[i] &lt; current) &#123;</span><br><span class="line">            left.push(arr[i])  //放在左边</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(arr[i]) //放在右边</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return quickSort(left).concat(current,quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/01/27/【前端该懂的服务器知识】linux彻底卸载nginx/" class="prev">PREV</a><a href="/2019/01/21/When to use var vs let vs const in JavaScript/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 <a href="http://yoursite.com">LJTin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>